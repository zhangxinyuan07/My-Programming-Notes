# 滑动窗口模板

```C++
// 模板
// int n = 数组长度;
for(int l = 0, r = 0; r < n; ++r) {
  // 右边滑入窗口；
  // while(不符合条件) 左边滑出窗口；l在这里+
  if(/* 满足条件 */)   // 记录
}
```



# 滑动窗口问题分类

## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, right = 0;
        int sum = 0, ans = INT_MAX;
        while (right < nums.size()) {
            sum += nums[right];
            while (sum >= target) {
                ans = min(ans, right - left + 1);
                sum -= nums[left];
                left++;
            }
            right++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```C++
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        // 滑动窗口的长度
        int pLen = p.size();
        int sLen = s.size();
        if (pLen > sLen) return {};

        vector<int> res;

        // 用两个数组分别统计p和滑动窗口中每个字符的数量
        vector<int> sCount(26, 0);
        vector<int> pCount(26, 0);
        for (int i = 0; i < pLen; i++) {
            sCount[s[i] - 'a']++;
            pCount[p[i] - 'a']++;
        }
        if (sCount == pCount) res.push_back(0);

        for (int i = 0; i < sLen - pLen; i++) {
            sCount[s[i] - 'a']--;
            sCount[s[i + pLen] - 'a']++;
            if (sCount == pCount) {
                res.push_back(i + 1);
            }
        }
        return res;
    }
};
```

## [713. 乘积小于K的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)

```C++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        
        if(k <= 1) return 0;
        int l = 0, r = 0, sum = 1, cnt = 0;

        // 对于每一个r, 找到对应的第一个l, 使得从l到r区间内所有的数乘起来小于k
        // 那么此时以r结尾的, 比这个区间长度小的所有子数组都满足要求, 而不必一个个去遍历了
        
        for(r = 0; r < nums.size(); r++){ 
            sum *= nums[r]; // r每加一就让sum乘以nums[r], 也避免了再从头算起
            while(sum >= k) sum /= nums[l++]; // 这一步和上一步才是体现和发挥滑动窗口优势的精髓
            cnt += r - l + 1; // 这一步很精髓
        }
        return cnt;
    }
};
```

## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

## [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)

