# 所有排序总结

<img src="%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1342700879_2982-16501811739252.jpg" alt="1342700879_2982" style="zoom:150%;" />

<img src="%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1342856655_3698-16501812668835.jpg" alt="1342856655_3698" style="zoom:150%;" />

## 时间复杂度

-   平方阶$O(n^2)$排序 : 

    各类简单排序:直接插入、直接选择和冒泡排序；

-   线性对数阶$O(nlog_2n)$排序 : 

    快速排序、堆排序和归并排序；

-   $O(n^{1 + §})$排序 ($§$是介于0和1之间的常数) : 

    希尔排序

-   线性阶$O(n)$排序 : 
    基数排序，此外还有桶、箱排序。

-   说明：

    -   当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至$O(n)$

    -   而快速排序则相反，当原表基本有序时，将退化为冒泡排序，时间复杂度提高到$O(n^2)$
    -   原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。

## 稳定性

-   **排序算法的稳定性 :** 若待排序的序列中, 存在多个具有相同关键字的记, 经过排序, 这些记录的相对次序保持不, 则称该算法是稳定; 若经排序, 记录的相对次序发生了改变, 则称该算法是不稳定的



-   **稳定性的好处：**排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较



-   **稳定的排序算法：**冒泡排序、插入排序、归并排序和基数排序

-   **不稳定的排序算法：**选择排序、快速排序、希尔排序、堆排序

 

## 选择排序算法的准则

每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。

影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：

1．待排序的记录数目n的大小；

2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；

3．关键字的结构及其分布情况；

4．对排序稳定性的要求。



设待排序元素的个数为n.

-   当n较大，则应采用时间复杂度为$O(nlog_2n)$的排序方法：快速排序、堆排序和归并排序。

    -   快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短
    -   堆排序 : 如果内存空间允许且要求稳定性

    -   归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。

-   当n较大，内存空间允许，且要求稳定性 =》归并排序

-   当n较小，可采用直接插入或直接选择排序。
    -   直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。
    -   直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序
-   一般不使用或不直接使用传统的冒泡排序。

-   基数排序
    它是一种稳定的排序算法，但有一定的局限性：
    1、关键字可分解。
    2、记录的关键字位数较少，如果密集更好
    3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。



# 归并排序

归并排序基于分治算法。最容易想到的实现方式是**自顶向下**的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 $O(logn)$。

如果要达到 $O(1)$ 的空间复杂度，则需要使用**自底向上**的实现方式。



## 自顶向下归并排序

对链表自顶向下归并排序的过程如下 : 

找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

对两个子链表分别排序。

将两个排序后的子链表合并，得到完整的排序后的链表。可以使用 [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) 的做法，将两个有序的子链表进行合并。

上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。





## 自底向上归并排序

使用自底向上的方法实现归并排序，则可以达到 O(1) 的空间复杂度。

首先求得链表的长度 length，然后将链表拆分成子链表进行合并。

具体做法如下。

用 subLength 表示每次需要排序的子链表的长度，初始时 subLength = 1。

每次将链表拆分成若干个长度为 subLength 的子链表（最后一个子链表的长度可以小于 subLength），按照每两个子链表一组进行合并，合并后即可得到若干个长度为 subLength × 2 的有序子链表（最后一个子链表的长度可以小于 subLength × 2）。合并两个子链表仍然使用 [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)  的做法。

将 subLength 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 length，整个链表排序完毕。





**具体写的感觉类似于把递归变成for循环，很难写，思路不好捋**



## 题目总结

### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

这道题考察了 : 

1. [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
2. 找到链表中点
3. 排序的时间复杂度
4. 归并排序的实现(**递归**的实现)



把拆分链表、合并链表、递归排序拆开写， 思路更清晰，更有利于掌控代码

**真是道好题!**



- 自顶向下

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return realSortFunc(head);
    }

private:
    ListNode* splitList(ListNode* head) {
        // 传入要被二等分的链表头节点head, 对链表进行二等分, 返回二等分后第二个链表的头节点

        ListNode* dummyHead = new ListNode(-1, head);
        // slow指向head前面的节点, 这样while循环结束后slow的下一个节点就是中点, 方便操作
        ListNode* fast = head, * slow = dummyHead; 
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        ListNode* newHead = slow->next;
        slow->next = nullptr;
        return newHead;
    }

    ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
        // 合并两个有序链表, 返回合并后的链表头节点, 合并后链表依然有序

        ListNode* dummyHead = new ListNode(-1); // 头部保留, 最后返回用
        ListNode* tail = dummyHead; // 表示结果链表的尾部, 下面要把节点依次往尾部添加

        ListNode* p1 = head1, * p2 = head2;
        while (p1 != nullptr && p2 != nullptr) {

            if (p1->val >= p2->val) {
                tail->next = p2;
                p2 = p2->next;
            }
            else {
                tail->next = p1;
                p1 = p1->next;
            }

            tail = tail->next;
        }

        // while 结束代表两个链表其中一个遍历完了
        // 这时把另一个链表剩余部分直接接到结果链表尾部去
        if (p1 == nullptr) tail->next = p2;
        else tail->next = p1;

        return dummyHead->next;
    }

    ListNode* realSortFunc(ListNode* head)  {
        // 真正的排序函数, 对传入的head链表进行排序, 返回排序完成后的链表

        if (head == nullptr || head->next == nullptr) {
            return head;
        }

        // 每一层的逻辑很简单 :
        // 1. 拆分链表
        ListNode* anotherHead = splitList(head);

        // 2. 把拆分后的两个链表进行排序, 得到两个有序子链表
        ListNode* head1 = realSortFunc(head);
        ListNode* head2 = realSortFunc(anotherHead);

        // 3. 排序完成后对两个有序子链表合并得到最终链表
        return mergeTwoLists(head1, head2);
    }


};
```

时间复杂度：$O(nlogn)$，其中 $n$ 是链表的长度。

空间复杂度：$O(logn)$，其中 $n$ 是链表的长度。空间复杂度主要取决于递归调用的栈空间。









- 自底向上

**理解和实现都很困难， 先把答案放这里， 后面再思考吧**

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        int length = getLength(head);
        if(length <= 1) return head;
        
        // 每次把链表拆分成若干个长度为subLen的子链表
        // 对每个子链表进行两两合并(合并完就是有序的)
        // 每次全部合并完, subLength变为之前的两倍
        // 然后继续合并若干个长度为subLength * 2的有序子链表, 直到全部合并完
        // z
        ListNode* dummyHead = new ListNode(0, head);
        for (int subLength = 1; subLength < length; subLength <<= 1) {
            ListNode* prev = dummyHead, *curr = dummyHead->next;
            while (curr != nullptr) {
                ListNode* head1 = curr;
                for (int i = 1; i < subLength && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* head2 = curr->next;
                curr->next = nullptr;
                curr = head2;
                for (int i = 1; i < subLength && curr != nullptr && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* next = nullptr;
                if (curr != nullptr) {
                    next = curr->next;
                    curr->next = nullptr;
                }
                ListNode* merged = mergeTwoLists(head1, head2);
                prev->next = merged;
                while (prev->next != nullptr) {
                    prev = prev->next;
                }
                curr = next;
            }
        }
        return dummyHead->next;
    }

// 下面这些都是自己写的, 也比较简单
private:
    int getLength(ListNode* head) {
        int len = 0;
        ListNode* cur = head;
        while (cur != nullptr) {
            cur = cur->next;
            len++;
        }
        return len;
    }

    ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode(-1);
        ListNode* tail = dummyHead;

        ListNode* p1 = head1, * p2 = head2;
        while (p1 && p2) {
            if (p1->val >= p2->val) {
                tail->next = p2;
                p2 = p2->next;
            } else {
                tail->next = p1;
                p1 = p1->next;
            }

            tail = tail->next;
        }
        tail->next = p1 ? p1 : p2;

        return dummyHead->next;
    }
};
```









# 选择排序







# 冒泡排序











# 插入排序













# 快速排序











# 堆排序
