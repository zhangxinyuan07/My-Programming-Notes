# 所有排序总结

<img src="%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1342700879_2982-16501811739252.jpg" alt="1342700879_2982" style="zoom:150%;" />

<img src="%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1342856655_3698-16501812668835.jpg" alt="1342856655_3698" style="zoom:150%;" />

## 时间复杂度

-   平方阶$O(n^2)$排序 : 

    各类简单排序:直接插入、直接选择和冒泡排序；

-   线性对数阶$O(nlog_2n)$排序 : 

    快速排序、堆排序和归并排序；

-   $O(n^{1 + §})$排序 ($§$是介于0和1之间的常数) : 

    希尔排序

-   线性阶$O(n)$排序 : 
    基数排序，此外还有桶、箱排序。

-   说明：

    -   当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至$O(n)$

    -   而快速排序则相反，当原表基本有序时，将退化为冒泡排序，时间复杂度提高到$O(n^2)$
    -   原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。

## 稳定性

-   **排序算法的稳定性 :** 若待排序的序列中, 存在多个具有相同关键字的记, 经过排序, 这些记录的相对次序保持不, 则称该算法是稳定; 若经排序, 记录的相对次序发生了改变, 则称该算法是不稳定的



-   **稳定性的好处：**排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较



-   **稳定的排序算法：**冒泡排序、插入排序、归并排序和基数排序

-   **不稳定的排序算法：**选择排序、快速排序、希尔排序、堆排序

 

## 选择排序算法的准则

每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。

影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：

1．待排序的记录数目n的大小；

2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；

3．关键字的结构及其分布情况；

4．对排序稳定性的要求。



设待排序元素的个数为n.

-   当n较大，则应采用时间复杂度为$O(nlog_2n)$的排序方法：快速排序、堆排序和归并排序。

    -   快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短
    -   堆排序 : 如果内存空间允许且要求稳定性

    -   归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。

-   当n较大，内存空间允许，且要求稳定性 =》归并排序

-   当n较小，可采用直接插入或直接选择排序。
    -   直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。
    -   直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序
-   一般不使用或不直接使用传统的冒泡排序。

-   基数排序
    它是一种稳定的排序算法，但有一定的局限性：
    1、关键字可分解。
    2、记录的关键字位数较少，如果密集更好
    3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。



# 归并排序

归并排序基于分治算法。最容易想到的实现方式是**自顶向下**的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 $O(logn)$。

如果要达到 $O(1)$ 的空间复杂度，则需要使用**自底向上**的实现方式。



## 自顶向下归并排序

对链表自顶向下归并排序的过程如下 : 

找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

对两个子链表分别排序。

将两个排序后的子链表合并，得到完整的排序后的链表。可以使用 [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) 的做法，将两个有序的子链表进行合并。

上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。





## 自底向上归并排序

使用自底向上的方法实现归并排序，则可以达到 O(1) 的空间复杂度。

首先求得链表的长度 length，然后将链表拆分成子链表进行合并。

具体做法如下。

用 subLength 表示每次需要排序的子链表的长度，初始时 subLength = 1。

每次将链表拆分成若干个长度为 subLength 的子链表（最后一个子链表的长度可以小于 subLength），按照每两个子链表一组进行合并，合并后即可得到若干个长度为 subLength × 2 的有序子链表（最后一个子链表的长度可以小于 subLength × 2）。合并两个子链表仍然使用 [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)  的做法。

将 subLength 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 length，整个链表排序完毕。





**具体写的感觉类似于把递归变成for循环，很难写，思路不好捋**



## 题目总结

### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

这道题考察了 : 

1. [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
2. 找到链表中点
3. 排序的时间复杂度
4. 归并排序的实现(**递归**的实现)



把拆分链表、合并链表、递归排序拆开写， 思路更清晰，更有利于掌控代码

**真是道好题!**



- 自顶向下

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return realSortFunc(head);
    }

private:
    ListNode* splitList(ListNode* head) {
        // 传入要被二等分的链表头节点head, 对链表进行二等分, 返回二等分后第二个链表的头节点

        ListNode* dummyHead = new ListNode(-1, head);
        // slow指向head前面的节点, 这样while循环结束后slow的下一个节点就是中点, 方便操作
        ListNode* fast = head, * slow = dummyHead; 
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        ListNode* newHead = slow->next;
        slow->next = nullptr;
        return newHead;
    }

    ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
        // 合并两个有序链表, 返回合并后的链表头节点, 合并后链表依然有序

        ListNode* dummyHead = new ListNode(-1); // 头部保留, 最后返回用
        ListNode* tail = dummyHead; // 表示结果链表的尾部, 下面要把节点依次往尾部添加

        ListNode* p1 = head1, * p2 = head2;
        while (p1 != nullptr && p2 != nullptr) {

            if (p1->val >= p2->val) {
                tail->next = p2;
                p2 = p2->next;
            }
            else {
                tail->next = p1;
                p1 = p1->next;
            }

            tail = tail->next;
        }

        // while 结束代表两个链表其中一个遍历完了
        // 这时把另一个链表剩余部分直接接到结果链表尾部去
        if (p1 == nullptr) tail->next = p2;
        else tail->next = p1;

        return dummyHead->next;
    }

    ListNode* realSortFunc(ListNode* head)  {
        // 真正的排序函数, 对传入的head链表进行排序, 返回排序完成后的链表

        if (head == nullptr || head->next == nullptr) {
            return head;
        }

        // 每一层的逻辑很简单 :
        // 1. 拆分链表
        ListNode* anotherHead = splitList(head);

        // 2. 把拆分后的两个链表进行排序, 得到两个有序子链表
        ListNode* head1 = realSortFunc(head);
        ListNode* head2 = realSortFunc(anotherHead);

        // 3. 排序完成后对两个有序子链表合并得到最终链表
        return mergeTwoLists(head1, head2);
    }


};
```

时间复杂度：$O(nlogn)$，其中 $n$ 是链表的长度。

空间复杂度：$O(logn)$，其中 $n$ 是链表的长度。空间复杂度主要取决于递归调用的栈空间。









- 自底向上

**理解和实现都很困难， 先把答案放这里， 后面再思考吧**

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        int length = getLength(head);
        if(length <= 1) return head;
        
        // 每次把链表拆分成若干个长度为subLen的子链表
        // 对每个子链表进行两两合并(合并完就是有序的)
        // 每次全部合并完, subLength变为之前的两倍
        // 然后继续合并若干个长度为subLength * 2的有序子链表, 直到全部合并完
        // z
        ListNode* dummyHead = new ListNode(0, head);
        for (int subLength = 1; subLength < length; subLength <<= 1) {
            ListNode* prev = dummyHead, *curr = dummyHead->next;
            while (curr != nullptr) {
                ListNode* head1 = curr;
                for (int i = 1; i < subLength && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* head2 = curr->next;
                curr->next = nullptr;
                curr = head2;
                for (int i = 1; i < subLength && curr != nullptr && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* next = nullptr;
                if (curr != nullptr) {
                    next = curr->next;
                    curr->next = nullptr;
                }
                ListNode* merged = mergeTwoLists(head1, head2);
                prev->next = merged;
                while (prev->next != nullptr) {
                    prev = prev->next;
                }
                curr = next;
            }
        }
        return dummyHead->next;
    }

// 下面这些都是自己写的, 也比较简单
private:
    int getLength(ListNode* head) {
        int len = 0;
        ListNode* cur = head;
        while (cur != nullptr) {
            cur = cur->next;
            len++;
        }
        return len;
    }

    ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode(-1);
        ListNode* tail = dummyHead;

        ListNode* p1 = head1, * p2 = head2;
        while (p1 && p2) {
            if (p1->val >= p2->val) {
                tail->next = p2;
                p2 = p2->next;
            } else {
                tail->next = p1;
                p1 = p1->next;
            }

            tail = tail->next;
        }
        tail->next = p1 ? p1 : p2;

        return dummyHead->next;
    }
};
```









# 选择排序







# 冒泡排序











# 插入排序













# 快速排序

## 快速排序的概念

快速排序是对[冒泡排序](http://data.biancheng.net/view/70.html)的一种改进

快速排序的==基本思想==是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。

## 快速排序的原理

排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第 1 个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。

**这是典型的分治思想，即分治法**。下面我们对一个实际例子进行算法描述，讲解快速排序的排序步骤。

以 47、29、71、99、78、19、24、47 的待排序的数列为例进行排序，为了方便区分两个 47，我们对后面的 47 增加一个下画线，即待排序的数列为 47、29、71、99、78、19、24、47。

首先我们需要在数列中选择一个基准数，我们一般会选择中间的一个数或者头尾的数，这里直接选择第 1 个数 47 作为基准数，接着把比 47 小的数字移动到左边，把比 47 大的数字移动到右边，对于相等的数字不做移动。所以实际上我们需要找到中间的某个位置 k，这样 k 左边的值全部比 k 上的值小，k 右边的值全部比 k 上的值大。

接下来开始移动元素。怎么移动呢？其实冒泡排序也涉及对元素的移动，但是那样移动起来很累，比如把最后一个元素移动到第 1 个，就需要比较 n-1 次，同时交换 n-1 次，效率很低。**其实，只需把第 1 个元素和最后一个元素交换就好了，这种思想是不是在排序时可以借鉴呢？之前说快速排序就是对冒泡排序的一个改进，就是这个原因。**

**快速排序的操作**是这样的：首先从数列的右边开始往左边找，我们设这个下标为 i，也就是进行减减操作（i--），找到第 1 个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，设这个下标为 j，然后执行加加操作（j++），找到第 1 个比基准数大的值，让它与基准值交换；然后继续寻找，直到 i 与 j 相遇时结束，最后基准值所在的位置即 k 的位置，也就是说 k 左边的值均比 k 上的值小，而 k 右边的值都比 k 上的值大。

所以对于上面的数列 47、29、71、99、78、19、24、47，进行第 1 趟第 1 个交换的排序情况如下，第 1 次的操作情况如图 1 所示。

<img src="%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1-1Q00220010V16.jpg" alt="img"  />

​													图 1 第 1 次发现可以交换的数


交换之后，j 移动到了下标为 6 的位置，对 i 继续扫描，如图 2 所示。

![img](%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1-1Q00220013M46.jpg)

​													图 2 第 2 次发现可交换的值

此时交换后的数列变为 24、29、47、99、78、19、71、47。接下来我们继续对 i、j 进行操作，如图 3 所示，继续进行 i-- 及 j++ 的比较操作。


![img](%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1-1Q00220025I54.jpg)

​													图 3 继续进行 i 与 j 的移动
进行了这两次 i、j 的移动、比较、交换之后，我们最终得到的数列是 24、29、19、47、78、99、71、47。接下来我们继续进行 i-- 的操作，发现在 i 为 4 时比 47 大不用交换，在 i 为 3 时与 j 相遇，这时就不需要继续移动、比较了，已经找到 k 了，并且 k 的值为 3。我们可以确认一下当前的数列是不是 k 左边的值都比 47 小，而 k 右边的值都比 47 大（由于要保持相对位置不变，所以 47 同样在基准值 47 的右边）。

47 这个值已经落到了它该在的位置，**第 1 趟排序完成了。接下来就是以 k 为基准，分为两部分，然后在左右两部分分别执行上述排序操作，最后数据会分为 4 部分；接着对每部分进行操作，直到每部分都只有一个值为止。**

接下来进行第 2 趟排序，现在左边部分为 24、29、19，我们选择第 1 个数 24 作为基准数，接着进行 i--、j++ 的操作，我们发现 i 最初的值为 19，比 24 这个基准值小，所以与基准值进行交换，得到的数列为 19、29、24；当 j 为 1 时，我们发现 29 比 24 大，所以与基准值进行交换，得到的数列 19、24、29，此时 i 为 2，j 为 1；继续 i-- 时发现 i 为 1，与 j 相遇，左边部分的数列的 k 为 1，并且左右两部分分别只有一个元素，此时第 2 轮排序的左边部分的排序结束，同时左边部分的所有数据都排序完成。

我们接着看右边部分的排序，待排序的数列为 78、99、71、47，我们同样选择第 1 个值 78 为基准值，接下来进行 i 与 j 的移动与比较，发现 47 比 78 小，进行交换，得到的数列 47、99、71、78；从左往右发现 99 比基准值 78 大，进行交换，得到的数列为 47、78、71、99；继续从右向左看，发现 71 比基准值 78 小，进行交换，得到的数列为 47、71、78、99。此时 i 在整体[数组](http://data.biancheng.net/view/181.html)中的下标为 6，j 为 5，若继续 j++ 则与 i 相遇，所以完成此轮排序。

此时右边数列的 k 为 6，一般会是相遇的位置，也就是基准值所在的位置，这时数列又被分为两部分，左边是 47、71，右边是 99，需要继续对左边部分的数据进行排序，虽然只有两个数据，但我们还是继续按照快速排序的思想操作一下，选择 47 作为基准数，将i进行从右向左的移动、比较，发现 i 与 j 相等时没有产生移动，完成第 2 轮排序。

至此，所有排序都已经完成，最终数列的结果是 19、24、29、47、47、71、78、99。实际上，**快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。**

要注意 ： **当基准数选择最左边的数字时，那么就应该先从右边开始搜索；当基准数选择最右边的数字时，那么就应该先从左边开始搜索。不论是从小到大排序还是从大到小排序！**

## 快速排序的特点及性能

 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是`O(n^2)`，它的平均时间复杂度为`O(nlogn)`。而事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。

快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的[空间复杂度](http://data.biancheng.net/view/2.html)为 `O(logn)`，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 `O(n)`。所以我们一般认为快速排序的空间复杂度为 `O(logn)`。

快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。

快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。



## 快速排序的实现

### 基础版

```C++
// 快速排序(从小到大)
void quickSort(int left, int right, vector<int>& arr) {
    // 1. 递归出口 : 通过分治使得区间被细分到只有一个元素
    if (left >= right) return;
    
    // 2. 每次取最左边的数作为基准数
    int i = left, j = right; 
    
    // 3. 把小于和大于base的数分别移到左半边和右半边
    while (i < j) {
        while (arr[j] >= arr[left] && i < j) j--;
        while (arr[i] <= arr[left] && i < j) i++;
        if (i < j) swap(arr[i], arr[j]);
    }
    
    // 退出循环时, i == j
    // 此时 i 和 j 共同指向的位置就是此轮排序完成后, 基准数应该在的位置
    // 4. 基准数归位
    swap(arr[i], arr[left]);
    
    //5. 分别递归左半边和右半边
    quickSort(left, i - 1, arr);
    quickSort(i + 1, right, arr);
}
```



### 加速版

每次选择都是选最左边的数, 可以改成随机选择一个数作为基准数



## 题目总结

### [剑指 Offer 40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

![Picture1.png](%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/1612615552-rifQwI-Picture1.png)

​								图1 标准的快速排序流程图

![image-20220608211010865](%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.assets/image-20220608211010865.png)

​								图2 基于快速排序的数组划分流程图

题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而**快速排序的基准数归位**可完成此目标。

根据快速排序原理，如果某次哨兵划分(基准数归位)后 **基准数正好是第 k+1 小的数字** ，那么此时基准数左边的所有数字便是题目所求的 最小的 k 个数 。

根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 k ，若 true 则直接返回此时数组的前 k 个数字即可。如基准数索引大于 k, 则说明第 k 大的数在当前基准数位置的左边, 那么只需要递归左区间, 反之则递归右区间。

- ==快速划分函数算法流程== ：

    1. 哨兵划分 ： 
        - 划分完毕后，基准数为 `arr[i]` ，左 / 右子数组区间分别为 `[l, i - 1] `, `[i + 1, r]`；
    2. 递归或者返回 ： 
        - 若 `k < i `，代表第 `k + 1` 小的数字在 左子数组 中，则递归左子数组；
            若 `k > i` ，代表第 `k + 1` 小的数字在 右子数组 中，则递归右子数组；
            若 `k = i` ，代表此时 `arr[k]` 即为第 `k + 1` 小的数字，则直接返回数组前 `k` 个数字即可；

- ==快速划分代码实现==：

    ```C++
    // 基于快速排序划分数组
    // 返回时使数组arr的前k个数为arr中最小的k个数
    void quickPartition(int left, int rignt, int k, vector<int>& arr) {
        int i = left, j = right;
        while (i < j) {
            while (i < j && arr[j] >= arr[left]) j--;
            while (i < j && arr[i] <= arr[left]) i++;
            swap(arr[i], arr[j]);
        }
        swap(arr[i], arr[left]);
        if (i > k) quickPartition(left, i - 1, k, arr);
        if (i < k) quickPartition(i + 1, right, k, arr);
       
    }
    ```




此题还可以自建一个大顶堆，利用大顶堆的性质来解决，具体做法在[这里](../数据结构总结/数据结构总结.md)的第七节中



### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)





# 堆排序

