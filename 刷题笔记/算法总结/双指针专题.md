# 二分查找

注意`mid`值最好用`mid = (right - left) / 2 + left`去算, 可避免超范围

二分查找时间复杂度为$O(logn)$



# 快慢指针法

## [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

此题最容易想到和最常见的解法是哈希表

但把每一位数字平方后相加得到下一个数的过程, 可以抽象为一个链表用next指针得到下一个节点, 从而此题可以变成链表是否有环的问题, 可用双指针把哈希表解法中的空间复杂度降到$O(1)$

### 哈希表

```C++
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> st;
        while (n != 1) {
            int sum = 0;
            while (n > 0) {
                int digit = n % 10;
                sum += digit * digit;
                n /= 10;
            }
            if (st.find(sum) != st.end()) return false;
            st.insert(sum);
            n = sum;
        }
        return true;

    }
};
```

### 快慢指针

```C++
class Solution {
public:
    int getNext(int n) {
     int totalSum = 0;
     while (n > 0) {
         int d = n % 10;
         n = n / 10;
         totalSum += d * d;
     }
     return totalSum;
 }

    bool isHappy(int n) {
        int slowRunner = n;
        int fastRunner = getNext(n);
        while (fastRunner != 1 && slowRunner != fastRunner) {
            slowRunner = getNext(slowRunner);
            fastRunner = getNext(getNext(fastRunner));
        }
        return fastRunner == 1;
    }
};
```

