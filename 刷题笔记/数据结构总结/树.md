

# 二叉树

## 完全二叉树

### 如何利用完全二叉树的性质?

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```C++
// Time complexity : O(logn * logn)
// Space complexity : O(1)

class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int level = 0;
        TreeNode* node = root;
        while (node->left != nullptr) {
            level++;
            node = node->left;
        }
        int low = 1 << level, high = (1 << (level + 1)) - 1;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (exists(root, level, mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    bool exists(TreeNode* root, int level, int k) {
        int bits = 1 << (level - 1);
        TreeNode* node = root;
        while (node != nullptr && bits > 0) {
            if (!(bits & k)) {
                node = node->left;
            } else {
                node = node->right;
            }
            bits >>= 1;
        }
        return node != nullptr;
    }
};
```

```C++
// Time complexity : O(logn * logn)
// Space complexity : O(logn)

class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftHeight = 0, rightHeight = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftHeight++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightHeight++;
        }
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

## 二叉搜索树

### 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

#### 递归验证

```C++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```

#### 利用二叉搜索树的性质 : 中序遍历序列有序

迭代 :

```C++
class Solution {
public:
    // 教科书式的迭代
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stk;
        if (root) stk.push(root);

        TreeNode* pre = nullptr;

        while (!stk.empty()) {
            TreeNode* node = stk.top();
            if (node) {
                stk.pop();

                if (node->right) stk.push(node->right);
                stk.push(node); stk.push(nullptr);
                if (node->left) stk.push(node->left);
            } else {
                stk.pop();
                node = stk.top(); 
                stk.pop();

                if (pre != nullptr && pre->val >= node->val) return false;
                pre = node;
            }
        }
        return true;
    }
};
```

递归 :

```C++
class Solution {
public:
 // 教科书式的递归
    TreeNode* pre = nullptr; 
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) return true;

        bool left = isValidBST(root->left);

        if (pre != nullptr && pre->val >= root->val) return false;
        pre = root;

        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

### 向二叉搜索树中插入节点

```C++
struct TreeNode {
 int val;
    TreeNode* left, * right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution{
public:
    //向根节点为root的二叉搜索树中插入值为val的一个节点
    bool insertBST(TreeNode* root, int val) {
        //递归终止条件：找到一个空位置就创建一个值为val的树节点
        if (!root) root = new TreeNode(val);
        //如果val等于某一个节点值，不符合二叉搜索树的定义，停止插入返回false
        else if (val == root->val) return false;
        //如果val比当前节点值小，就插入到当前节点的左子树中
        else if (val < root->val) insertBST(root->left, val);
        //如果val比当前节点值大，就插入到当前节点的右子树中
        else insertBST(root->right, val);
        return true;
    }
};
```





## 遍历

### 深度优先遍历

#### 递归写法

##### 前序(中左右)

```C++
void preOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
    
    preOrder(root->left);
    preOrder(root->right);
}
```

##### ==中序(左中右)==

```C++
void midOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    preOrder(root->left);
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
    
    preOrder(root->right);
}
```

##### 后序(左右中)

```C++
void postOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    preOrder(root->left);
    preOrder(root->right);
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
}
```

#### 迭代写法

下面这种写法能够统一前中后序的代码, 只需改变中间几行的顺序就可以实现三种方式遍历。

核心思想是通过在要处理的节点前面加入一个空指针作为标记，如果循环过程中碰到栈顶是空指针，则立刻弹出空指针，此时栈顶元素即为要处理的节点，即可进行处理。

如果栈顶不是空指针，那就把这个元素先弹出，然后按照前序遍历的顺序翻着压入栈中（因为栈后入先出），即右儿子–左儿子–根节点–空指针的顺序。

##### 前序

```C++
curvoid preOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    while (!stk.empty()) {
  TreeNode* cur = stk.top();
        if (cur) {
            stk.pop();
            
            if (cur->right) stk.push(cur->right); // 右
            if (cur->left) stk.push(cur->left);  // 左
            
            stk.push(cur);       // 中
            stk.push(nullptr);
            
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return;
}
```

##### ==中序==

```C++
void midOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    
    // 这里可能会根据解题需要加入一些东西
    
    while (!stk.empty()) {
        TreeNode* cur = stk.top();
        if (cur) {
            //这一部分不会变
            stk.pop();
            
            if (cur->right) stk.push(cur->right); // 右
            stk.push(cur); stk.push(nullptr);     // 中
            if (cur->left) stk.push(cur->left);  // 左
            
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            //这里自由发挥
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return; // 这里要看不同题目要求返回什么就返回什么
}
```

##### 后序

```C++
void postOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    while (!stk.empty()) {
  TreeNode* cur = stk.top();
        if (cur) {
            stk.pop();
            
            stk.push(cur);       // 中
            stk.push(nullptr);      
            
            if (cur->right) stk.push(cur->right); // 右
            if (cur->left) stk.push(cur->left); // 左
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return; // 这里要看不同题目要求返回什么就返回什么
}
```

### 广度优先遍历(层序遍历)

  广度优先搜索需要一个队列，开始先把根节点入队，然后进行如下循环：

把队首节点赋给`current`；

若`current`节点的左儿子存在，入队； 若`current`节点的右儿子存在，入队；

然后首节点出队。

进行上述循环直到队列为空。

**广度优先搜索的代码如下：**

```C++
struct TreeNode {
    int val;
    TreeNode* left, * right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void BFS(TreeNode* root) {
        queue<TreeNode*> Q;
        Q.push(root);
        while (!Q.empty()) {
            TreeNode* current = Q.front();Q.pop();
            if (current->left) Q.push(current->left);
            if (current->right) Q.push(current->right);
            cout << current->val << endl;
        } 
};
```

**==把每一层的节点都处理完再进入下一层的版本== :**

```C++
void BFS(TreeNode* root) {
 queue<TreeNode*> Q;
    Q.push(root);
    while (!Q.empty()) {
  		int n = Q.size();
        for (int i = 0; i < n; i++) {
   	TreeNode* cur = Q.front(); Q.pop();
            
            //这里写对当前节点的操作...
            
            if (cur->left) Q.push(cur->left);
            if (cur->right) Q.push(cur->right);
        }
    }
    return;
}
```





## 构造二叉树

### 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

不会

### 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

不会

### 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

不会









# 字典树(前缀树)

## `Trie`简介

`Trie` 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。

为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：

```c++
struct TreeNode {
    VALUETYPE value;    //结点值
    TreeNode* children[NUM];    //指向孩子结点
};
```



而 `Trie` 的结点是这样的(假设只包含'a'~'z'中的字符)：

```c++
struct TrieNode {
    bool isEnd; //该结点是否是一个串的结束
    TrieNode* next[26]; //字母映射表
};
```

要想学会` Trie `就得先明白它的结点设计。我们可以看到`TrieNode`结点中并没有直接保存字符值的数据成员，那它是怎么保存字符的呢？



这时字母映射表`next` 的妙用就体现了，`TrieNode* next[26]`中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：

```c++
for (int i = 0; i < 26; i++) {
    char ch = 'a' + i;
    if (parentNode->next[i] == NULL) {
        说明父结点的后一个字母不可为 ch
    } else {
        说明父结点的后一个字母可以是 ch
    }
}
```

我们来看个例子吧。

想象以下，包含三个单词 "sea","sells","she" 的 `Trie` 会长啥样呢？

它的真实情况是这样的：

![来自算法4](%E6%A0%91.assets/e3c98484881bd654daa8419bcb0791a2b6f8288b58ef50df70ddaeefc4084f48-file_1575215107950.png)

`Trie` 中一般都含有大量的空链接，因此在绘制一棵单词查找树时一般会忽略空链接，同时为了方便理解我们可以画成这样：

![实际并非如此，但我们仍可这样理解](%E6%A0%91.assets/3a0be6938b0a5945695fcddd29c74aacc7ac30f040f5078feefab65339176058-file_1575215106942.png)

接下来我们一起来实现对 `Trie` 的一些常用操作方法 : 

### 定义类 Trie

```C++
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    //方法将在下文实现...
};
```



### 插入

描述：向` Trie `中插入一个单词 word

实现：这个操作和构建链表很像。首先从根结点的子结点开始与 word 第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，同时还要将最后一个结点 `isEnd = true`;，表示它是一个单词的末尾。

```C++
void insert(string word) {
    Trie* node = this;
    for (char c : word) {
        if (node->next[c-'a'] == NULL) {
            node->next[c-'a'] = new Trie();
        }
        node = node->next[c-'a'];
    }
    node->isEnd = true;
}
```





### 查找

描述：查找 `Trie` 中是否存在单词 word

实现：从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回 false，如果匹配到了最后一个字符，那我们只需判断 `node->isEnd` 即可。

```C++
bool search(string word) {
    Trie* node = this;
    for (char c : word) {
        node = node->next[c - 'a'];
        if (node == NULL) {
            return false;
        }
    }
    return node->isEnd;
}
```





### 前缀匹配

描述：判断 `Trie` 中是或有以 prefix 为前缀的单词

实现：和 search 操作类似，只是不需要判断最后一个字符结点的`isEnd`，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的。

```C++
    Trie* node = this;
    for (char c : prefix) {
        node = node->next[c-'a'];
        if (node == NULL) {
            return false;
        }
    }
    return true;
}
```



### 总结

通过以上介绍和代码实现我们可以总结出 `Trie` 的几点性质：

1. Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。
2. 查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，**和 Trie 中包含多少个单词无关**。
3. Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为$ O(m^n)$。

最后，关于 Trie 的应用场景，希望你能记住 8 个字：**==一次建树，多次查询==**。(慢慢领悟叭~~)





## [实现`Trie`(前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

请你实现 `Trie` 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 ` true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。



```C++
class Trie {
public:
    Trie() : children(26), isEnd(false) {

    }
    
    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this->searchPrefix(word);
        return node != nullptr && node->isEnd;
    }
    
    bool startsWith(string prefix) {
        return this->searchPrefix(prefix) != nullptr;
    }

private:  
    // 字典树 (OR前缀树)
    // 这是一颗多叉树
    // 二叉树TreeNode有左右儿子 : TreeNode* left, * right
    // 类似地, 多叉树Trie每个儿子类型为Trie*, 它们统一放在一个数组里管理
    // 二叉树每个节点不仅存放指向左右儿子的指针, 通常还存放了一个int类型的节点值val
    // 类似地, 多叉树每个节点也有一个值, 对于本题, 可以用一个bool类型的isEnd来实现
    // isEnd用来表示该节点是否是字符串的结尾
    vector<Trie*> children;
    bool isEnd;

    Trie* searchPrefix(string prefix) {
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                return nullptr;
            }
            node = node->children[ch];
        }
        return node;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```























# 线段树





