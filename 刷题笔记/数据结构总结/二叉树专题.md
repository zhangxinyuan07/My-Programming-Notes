

# 完全二叉树

## 如何利用完全二叉树的性质?

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```C++
// Time complexity : O(logn * logn)
// Space complexity : O(1)

class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int level = 0;
        TreeNode* node = root;
        while (node->left != nullptr) {
            level++;
            node = node->left;
        }
        int low = 1 << level, high = (1 << (level + 1)) - 1;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (exists(root, level, mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    bool exists(TreeNode* root, int level, int k) {
        int bits = 1 << (level - 1);
        TreeNode* node = root;
        while (node != nullptr && bits > 0) {
            if (!(bits & k)) {
                node = node->left;
            } else {
                node = node->right;
            }
            bits >>= 1;
        }
        return node != nullptr;
    }
};
```

```C++
// Time complexity : O(logn * logn)
// Space complexity : O(logn)

class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftHeight = 0, rightHeight = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftHeight++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightHeight++;
        }
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

# 二叉搜索树

## 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

## 递归验证

```C++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```

## 利用二叉搜索树的性质 : 中序遍历序列有序

迭代 :

```C++
class Solution {
public:
    // 教科书式的迭代
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stk;
        if (root) stk.push(root);

        TreeNode* pre = nullptr;

        while (!stk.empty()) {
            TreeNode* node = stk.top();
            if (node) {
                stk.pop();

                if (node->right) stk.push(node->right);
                stk.push(node); stk.push(nullptr);
                if (node->left) stk.push(node->left);
            } else {
                stk.pop();
                node = stk.top(); 
                stk.pop();

                if (pre != nullptr && pre->val >= node->val) return false;
                pre = node;
            }
        }
        return true;
    }
};
```

递归 :

```C++
class Solution {
public:
 // 教科书式的递归
    TreeNode* pre = nullptr; 
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) return true;

        bool left = isValidBST(root->left);

        if (pre != nullptr && pre->val >= root->val) return false;
        pre = root;

        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

# 遍历

## 深度优先遍历

### 递归写法

#### 前序(中左右)

```C++
void preOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
    
    preOrder(root->left);
    preOrder(root->right);
}
```

#### ==中序(左中右)==

```C++
void midOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    preOrder(root->left);
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
    
    preOrder(root->right);
}
```

#### 后序(左右中)

```C++
void postOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    preOrder(root->left);
    preOrder(root->right);
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
}
```

### 迭代写法

下面这种写法能够统一前中后序的代码, 只需改变中间几行的顺序就可以实现三种方式遍历。

核心思想是通过在要处理的节点前面加入一个空指针作为标记，如果循环过程中碰到栈顶是空指针，则立刻弹出空指针，此时栈顶元素即为要处理的节点，即可进行处理。

如果栈顶不是空指针，那就把这个元素先弹出，然后按照前序遍历的顺序翻着压入栈中（因为栈后入先出），即右儿子–左儿子–根节点–空指针的顺序。

#### 前序

```C++
curvoid preOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    while (!stk.empty()) {
  TreeNode* cur = stk.top();
        if (cur) {
            stk.pop();
            
            if (cur->right) stk.push(cur->right); // 右
            if (cur->left) stk.push(cur->left);  // 左
            
            stk.push(cur);       // 中
            stk.push(nullptr);
            
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return;
}
```

#### ==中序==

```C++
void midOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    
    // 这里可能会根据解题需要加入一些东西
    
    while (!stk.empty()) {
        TreeNode* cur = stk.top();
        if (cur) {
            //这一部分不会变
            stk.pop();
            
            if (cur->right) stk.push(cur->right); // 右
            stk.push(cur); stk.push(nullptr);     // 中
            if (cur->left) stk.push(cur->left);  // 左
            
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            //这里自由发挥
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return; // 这里要看不同题目要求返回什么就返回什么
}
```

#### 后序

```C++
void postOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    while (!stk.empty()) {
  TreeNode* cur = stk.top();
        if (cur) {
            stk.pop();
            
            stk.push(cur);       // 中
            stk.push(nullptr);      
            
            if (cur->right) stk.push(cur->right); // 右
            if (cur->left) stk.push(cur->left); // 左
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return; // 这里要看不同题目要求返回什么就返回什么
}
```

## 广度优先遍历(层序遍历)

  广度优先搜索需要一个队列，开始先把根节点入队，然后进行如下循环：

把队首节点赋给`current`；

若`current`节点的左儿子存在，入队； 若`current`节点的右儿子存在，入队；

然后首节点出队。

进行上述循环直到队列为空。

**广度优先搜索的代码如下：**

```C++
struct TreeNode {
    int val;
    TreeNode* left, * right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void BFS(TreeNode* root) {
        queue<TreeNode*> Q;
        Q.push(root);
        while (!Q.empty()) {
            TreeNode* current = Q.front();Q.pop();
            if (current->left) Q.push(current->left);
            if (current->right) Q.push(current->right);
            cout << current->val << endl;
        } 
};
```

**==把每一层的节点都处理完再进入下一层的版本== :**

```C++
void BFS(TreeNode* root) {
 queue<TreeNode*> Q;
    Q.push(root);
    while (!Q.empty()) {
  int n = Q.size();
        for (int i = 0; i < n; i++) {
   TreeNode* cur = Q.front(); Q.pop();
            
            //这里写对当前节点的操作...
            
            if (cur->left) Q.push(cur->left);
            if (cur->right) Q.push(cur->right);
        }
    }
    return;
}
```

# 向二叉搜索树中插入节点

```C++
struct TreeNode {
 int val;
    TreeNode* left, * right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution{
public:
    //向根节点为root的二叉搜索树中插入值为val的一个节点
    bool insertBST(TreeNode* root, int val) {
        //递归终止条件：找到一个空位置就创建一个值为val的树节点
        if (!root) root = new TreeNode(val);
        //如果val等于某一个节点值，不符合二叉搜索树的定义，停止插入返回false
        else if (val == root->val) return false;
        //如果val比当前节点值小，就插入到当前节点的左子树中
        else if (val < root->val) insertBST(root->left, val);
        //如果val比当前节点值大，就插入到当前节点的右子树中
        else insertBST(root->right, val);
        return true;
    }
};
```

# 构造二叉树

## 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

不会

## 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

不会

## 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

不会