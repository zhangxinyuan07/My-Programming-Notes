# 数组

## C++遍历vector数组的方法

### 一维

#### 下标

```C++
int n = valList.size(); 
for (int i = 0; i < count;i++) 
{ 
    cout << valList[i] << endl; //或者 cout << valList.at(i) << endl;
}
```

#### 迭代器

```C++
for (vector::const_iterator it = valList.begin(); it != valList.end(); it++) 
//或者for(auto it = valList.begin(); it != end(); it++)
{ 
    cout << (*it) << endl;
}
```

#### `auto`关键字

```C++
for (auto val : valList)
{ 
    cout << val << endl;
}
```

#### `for_each`加函数

```c++
template
void printer(const T& val)
{ 
    cout << val << endl;
}

for_each(valList.begin(), valList.end(), printer);
```

#### `for_each`加仿函数

```C++
template
struct func
{ 
    void operator()(const T& obj) 
    { 
        cout << obj << endl;
    }
};

for_each(valList.begin(), valList.end(), func());

```

### 二维

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {

  vector<vector<int> > v = {{1,2}, {3,4}};
  for (const auto& inner : v) {
      for (const auto& item : inner) {
          cout << item << " ";
      }
  }
  cout << endl;

  return 0;
}
```

## 创建一个指定大小的二维数组

### 方法一

```C++
 const int a = 5;
 const int b =7;
 int data[a][b];
```

### 方法二

```C++
vector<vector<int>> grid(2,vector<int>(5, 0));
```

## vector与set互转

```C++
#include<set>
#include<vector>
#include<iostream>
using namespace std;


int main()
{
    vector<int> vec;
    vec = { 1, 2, 3, 4, 8, 9, 3, 2, 1, 0, 4, 8 };
    set<int> st(vec.begin(), vec.end());
    vec.assign(st.begin(), st.end());

    vector<int>::iterator it;
    for (it = vec.begin(); it != vec.end(); it++)
        cout << *it<<endl;
    
    return 0;
}

//输出 : 0 1 2 3 4 8 9 
```

# 链表

```C++
// 链表定义
ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) : val(x), next(next) {}
};
```

## 插入节点

### 在`head`前面插入一个值为`-1`的节点并用名为`dummyHead`的指针指向该节点

```C++
ListNode* dummyHead = new ListNode(-1, head);
```

### 在`cur`后面插入一个值为`val`的节点

```C++
ListNode* cur->next = new ListNode(val, cur->next);
```

# 字符串

## C++比较两字符串是否相等

### 最方便的

```c++
//不论是什么类型，只要被比较的双方是同一种即可
str1 == str2
char1 == char2
```

### char型字符串

```C++
strcmp(const char s1,const char s2)
//当 str1 < str2 时，返回为负数(-1)；
//当 str1 == str2 时，返回0；
//当 str1 > str2 时，返回正数(1)。
```

### string型字符串

```C++
s1.compare(s2)
//当s1 < s2时，返回为负数(-1)；
//当s1 == s2时，返回0；
//当s1 > s2时，返回正数(1)。
```

## char型的数字变成int型数字

`'9' - '0' = 9`

# 哈希表

## `unordered_set`, `unordered_map`与`set`, `map`的区别

关联容器使用的底层数据结构为**树**，而无序关联容器使用的是**哈希表**。

`map`为自平衡二叉搜索树(BST)

STL中，`map`对应的数据结构是**红黑树**。红黑树是一种近似于平衡的二叉查找树，里面的数据是有规律地做的。在红黑树上发现操作的时间复杂度为 $O(logn)$ 时间。而`unordered_map`对应**哈希表**，哈希表的特点就是查找效率高，时间复杂度为常数级别$O(1)$, 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用`unordered_map`容器。而如果对内存大小比较敏感或者数据存储要求顺序，则可以使用`map`容器。

## 向哈希表中添加元素

```C++
string s = "abccccdd";
unordered_map<char, int> count;
for (char c : s) {
    ++count[c]; // 写得好!
}
```

# 栈与队列



# 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。

时间复杂度为$O(n)$。
