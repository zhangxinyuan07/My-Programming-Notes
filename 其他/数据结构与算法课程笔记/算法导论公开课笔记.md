# 第一节：算法分析



## **渐进分析**

渐进即趋于无穷大时

1. 忽略依赖机器的常量
2. 不去检查实际的运行时间，而是关注运行时间的增长



## **渐进符号**

大O表示法：忽略低阶项和常数因子





## **插入排序**

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

<img src="/Users/zhangxinyuan/Nutstore Files/坚果云/坚果云文稿/Markdown文稿/数据结构与算法笔记/算法导论公开课笔记.assets/f3.png" alt="cc" style="zoom: 67%;" />

### 算法复杂度

时间复杂度：O(n^2)



### 伪代码

```python
INSERTION-SORT(A)			//A是数组
 for j = 2 to A.length
	key = A[j]
	//(将A[j]插入排序序列A[1..j-1])
	i = j - 1
	while i > 0 and A[i] > key
		A[i+1] = A[i]
		i = i - 1
	A[i+1] = key
```



### 代码实现

#### C++

```c++
void insertion_sort(int arr[],int len)
{
    for(int i=1;i<len;i++)
    {
        int key=arr[i];
        int j=i-1;
        while((j>=0) && (key<arr[j]))
        {
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
}
```



#### Python3

```python
def insertionSort(arr):
 	for i in range(len(arr)):
 		preIndex = i-1
    	current = arr[i]
    	while preIndex >= 0 and arr[preIndex] > current:
      		arr[preIndex+1] = arr[preIndex]
      		preIndex-=1
    	arr[preIndex+1] = current
  	return arr
```



## 归并排序

采用分治法:

- 分割：递归地把当前序列平均分割成两半。
- 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）

![img](/Users/zhangxinyuan/Nutstore Files/坚果云/坚果云文稿/Markdown文稿/数据结构与算法笔记/算法导论公开课笔记.assets/1024555-20161218163120151-452283750.png)

### 算法复杂度

时间复杂度：O(nlogn)

空间复杂度：O(n)



### 归并操作

归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。

#### 递归法（Top-down）

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

#### 迭代法（Bottom-up）

原理如下（假设序列共有{\displaystyle n}![n](https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b)个元素）：

1. 将序列每相邻两个数字进行归并操作，形成{\displaystyle ceil(n/2)}![{\displaystyle ceil(n/2)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/284284713ad8f1ba13458b896c87efc4b9b7df9c)个序列，排序后每个序列包含两/一个元素
2. 若此时序列数不是1个则将上述序列再次归并，形成{\displaystyle ceil(n/4)}![{\displaystyle ceil(n/4)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0f7b6be8e0c402e981a78d573dc3072c3d24a3c4)个序列，每个序列包含四/三个元素
3. 重复步骤2，直到所有元素排序完毕，即序列数为1



### 代码实现

#### C++

迭代版：

```c++
template<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(<)的算子功能
void merge_sort(T arr[], int len) {
    T *a = arr;
    T *b = new T[len];
    for (int seg = 1; seg < len; seg += seg) {
        for (int start = 0; start < len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            while (start1 < end1 && start2 < end2)
                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
            while (start1 < end1)
                b[k++] = a[start1++];
            while (start2 < end2)
                b[k++] = a[start2++];
        }
        T *temp = a;
        a = b;
        b = temp;
    }
    if (a != arr) {
        for (int i = 0; i < len; i++)
            b[i] = a[i];
        b = a;
    }
    delete[] b;
}
```

递归版：

```
void Merge(vector<int> &Array, int front, int mid, int end) {
    // preconditions:
    // Array[front...mid] is sorted
    // Array[mid+1 ... end] is sorted
    // Copy Array[front ... mid] to LeftSubArray
    // Copy Array[mid+1 ... end] to RightSubArray
    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);
    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);
    int idxLeft = 0, idxRight = 0;
    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());
    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());
    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]
    for (int i = front; i <= end; i++) {
        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) {
            Array[i] = LeftSubArray[idxLeft];
            idxLeft++;
        } else {
            Array[i] = RightSubArray[idxRight];
            idxRight++;
        }
    }
}

void MergeSort(vector<int> &Array, int front, int end) {
    if (front >= end)
        return;
    int mid = front + (end - front) / 2;
    MergeSort(Array, front, mid);
    MergeSort(Array, mid + 1, end);
    Merge(Array, front, mid, end);
}
```

#### Python3

```python
def mergeSort(nums):
    if len(nums) < 2:
        return nums
    mid = len(nums) // 2
    left = mergeSort(nums[:mid])
    right = mergeSort(nums[mid:])
    result = []
    while left and right:
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    if left:
        result += left
    if right:
        result += right
    return result


if __name__ == "__main__":
    nums = [1, 4, 2, 3.6, -1, 0, 25, -34, 8, 9, 1, 0]
    print("original:", nums)
    print("Sorted:", mergeSort(nums))
```





## 分析分治算法

假设把原问题分解成 a 个子问题，每个子问题的规换是原问题的$1/b$.为了求解一个规模为 $1/b$ 的子问题，需要 $T(n/b)$的时间，所以需要$ aT(1/b)$的时间来求解 $a $个子问题.如果分解问题 成子问题需要时间 $D(n)$，合并子问题的解成原问题的解需要时间$ C(n)$，那么得到递归式：
$$
T(n)= \begin{cases} \Theta(1), & \text {若 $n \leq c$} \\ aT(n/b)+D(n)+C(n), & \text{其他} \end{cases}
$$








## 五种排序算法总结

|          | 快速排序 | 归并排序 | 堆排序 | 插入排序 | 选择排序 |
| :------- | :------- | :------- | :----- | :------- | -------- |
| 最好情况 | NlogN    | NlogN    | NlogN  | N        | N^2      |
| 平均情况 | NlogN    | NlogN    | NlogN  | N^2      | N^2      |
| 最坏情况 | N^2      | NlogN    | NlogN  | N^2      | N^2      |





# 第二节：数据结构与算法

1. **解决问题方法的效率，跟数据的组织方式有关**

2. **解决问题方法的效率，跟空间的利用效率有关**

3. **解决问题方法的效率，跟算法的巧妙程度有关** 



## 什么是数据结构？

**数据对象**在计算机中的组织方式

- 逻辑结构
    - 一对一：线性
    - 一对多：树
    - 多对多：图
- 物理结构



数据对象必定与一系列加在其上的**操作**相关联

完成这些操作所用的方法就是**算法**



**抽象数据类型（Abstract Data Type）**

- 数据类型

    - 数据对象集
    - 数据集合相关联的操作集

- 抽象：描述数据类型的方法不依赖于具体实现

    - 与机器无关
    - 与物理结构无关
    - 与算法和语言无关

    只描述数据对象集和相关操作集“是什么”，不涉及“如何做到”的问题



## 什么是算法？

- 算法（Algorithm）
    - 一个有限指令集
    - 接受输入
    - 产生输出
    - 有限步骤后终止
    - 指令无歧义、计算机可处理
    - 指令的描述不依赖于任何一种计算机语言以及具体实现手段



## 什么是好的算法？

### 复杂度

**空间复杂度 $S(n)$**



**时间复杂度 $T(n)$**

<img src="/Users/zhangxinyuan/Nutstore Files/坚果云/坚果云文稿/Markdown文稿/数据结构与算法笔记/算法导论公开课笔记.assets/CleanShot 2021-05-20 at 16.40.23@2x.png" alt="CleanShot 2021-05-20 at 16.40.23@2x" style="zoom: 25%;" />



- 分析一般算法的效率时，我们经常关注下面两种复杂度：

    - 最坏情况复杂度 $T_{worst}(n)$

    - 平均复杂度$T_{avg}(n)$

        $T_{avg}(n) \leq T_{worst}(n)$



### 复杂度的渐进表示法

- $T(n)=O(f(n))$ 表示存在常数 $C>0,n_0>0$ 使得当 $n\geq n_0$ 时有 $T(n) \leq C \cdot f(n)$ ，即（最小）**上界**
- $T(n)= \Omega(g(n))$  表示存在常数 $C>0,n_0>0$ 使得当 $n\geq n_0$ 时有 $T(n) \geq C \cdot g(n)$ ，即（最大）**下界**

- $T(n)= \Theta(h(n))$  表示同时有$T(n)=O(h(n))$ 和 $T(n)= \Omega(h(n))$  



### 复杂度分析小窍门

<img src="/Users/zhangxinyuan/Nutstore Files/坚果云/坚果云文稿/Markdown文稿/数据结构与算法笔记/算法导论公开课笔记.assets/CleanShot 2021-05-20 at 17.07.42@2x.png" alt="CleanShot 2021-05-20 at 17.07.42@2x" style="zoom:50%;" />





# 第三节：线性结构

















![CleanShot 2021-06-06 at 15.08.06@2x](/Users/zhangxinyuan/Nutstore Files/坚果云/坚果云文稿/Markdown文稿/数据结构与算法笔记/算法导论公开课笔记.assets/CleanShot 2021-06-06 at 15.08.06@2x.png)















































































