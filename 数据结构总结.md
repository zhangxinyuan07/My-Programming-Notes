# 数组

## C++遍历vector数组的方法

### 一维

#### 下标

```C++
int n = valList.size(); 
for (int i = 0; i < count;i++) 
{ 
    cout << valList[i] << endl; //或者 cout << valList.at(i) << endl;
}
```

#### 迭代器

```C++
for (vector::const_iterator it = valList.begin(); it != valList.end(); it++) 
//或者for(auto it = valList.begin(); it != end(); it++)
{ 
    cout << (*it) << endl;
}
```

#### `auto`关键字

```C++
for (auto val : valList)
{ 
    cout << val << endl;
}
```

#### `for_each`加函数

```c++
template
void printer(const T& val)
{ 
    cout << val << endl;
}

for_each(valList.begin(), valList.end(), printer);
```

#### `for_each`加仿函数

```C++
template
struct func
{ 
    void operator()(const T& obj) 
    { 
        cout << obj << endl;
    }
};

for_each(valList.begin(), valList.end(), func());

```

### 二维

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {

  vector<vector<int> > v = {{1,2}, {3,4}};
  for (const auto& inner : v) {
      for (const auto& item : inner) {
          cout << item << " ";
      }
  }
  cout << endl;

  return 0;
}
```

## 创建一个指定大小的二维数组

### 方法一

```C++
 const int a = 5;
 const int b =7;
 int data[a][b];
```

### 方法二

```C++
vector<vector<int>> grid(2,vector<int>(5, 0));
```

## vector与set互转

```C++
#include<set>
#include<vector>
#include<iostream>
using namespace std;


int main()
{
    vector<int> vec;
    vec = { 1, 2, 3, 4, 8, 9, 3, 2, 1, 0, 4, 8 };
    set<int> st(vec.begin(), vec.end());
    vec.assign(st.begin(), st.end());

    vector<int>::iterator it;
    for (it = vec.begin(); it != vec.end(); it++)
        cout << *it<<endl;
    
    return 0;
}

//输出 : 0 1 2 3 4 8 9 
```

# 链表

```C++
// 链表定义
ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) : val(x), next(next) {}
};
```

## 插入节点

### 在`head`前面插入一个值为`-1`的节点并用名为`dummyHead`的指针指向该节点

```C++
ListNode* dummyHead = new ListNode(-1, head);
```

### 在`cur`后面插入一个值为`val`的节点

```C++
ListNode* cur->next = new ListNode(val, cur->next);
```

# 字符串

## C++比较两字符串是否相等

### 最方便的

```c++
//不论是什么类型，只要被比较的双方是同一种即可
str1 == str2
char1 == char2
```

### char型字符串

```C++
strcmp(const char s1,const char s2)
//当 str1 < str2 时，返回为负数(-1)；
//当 str1 == str2 时，返回0；
//当 str1 > str2 时，返回正数(1)。
```

### string型字符串

```C++
s1.compare(s2)
//当s1 < s2时，返回为负数(-1)；
//当s1 == s2时，返回0；
//当s1 > s2时，返回正数(1)。
```

## char型的数字变成int型数字

`'9' - '0' = 9`

# 哈希表

## `unordered_set`, `unordered_map`与`set`, `map`的区别

关联容器使用的底层数据结构为**树**，而无序关联容器使用的是**哈希表**。

`map`为自平衡二叉搜索树(BST)

STL中，`map`对应的数据结构是**红黑树**。红黑树是一种近似于平衡的二叉查找树，里面的数据是有规律地做的。在红黑树上发现操作的时间复杂度为 $O(logn)$ 时间。而`unordered_map`对应**哈希表**，哈希表的特点就是查找效率高，时间复杂度为常数级别$O(1)$, 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用`unordered_map`容器。而如果对内存大小比较敏感或者数据存储要求顺序，则可以使用`map`容器。

## 向哈希表中添加元素

```C++
string s = "abccccdd";
unordered_map<char, int> count;
for (char c : s) {
    ++count[c]; // 写得好!
}
```

# 栈与队列

# 二叉树

## 完全二叉树

### 如何利用完全二叉树的性质?

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```C++
// Time complexity : O(logn * logn)
// Space complexity : O(1)

class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int level = 0;
        TreeNode* node = root;
        while (node->left != nullptr) {
            level++;
            node = node->left;
        }
        int low = 1 << level, high = (1 << (level + 1)) - 1;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (exists(root, level, mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    bool exists(TreeNode* root, int level, int k) {
        int bits = 1 << (level - 1);
        TreeNode* node = root;
        while (node != nullptr && bits > 0) {
            if (!(bits & k)) {
                node = node->left;
            } else {
                node = node->right;
            }
            bits >>= 1;
        }
        return node != nullptr;
    }
};
```

```C++
// Time complexity : O(logn * logn)
// Space complexity : O(logn)

class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftHeight = 0, rightHeight = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftHeight++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightHeight++;
        }
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

## 二叉搜索树

### 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

### 递归验证

```C++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```

### 利用二叉搜索树的性质 : 中序遍历序列有序

迭代 :

```C++
class Solution {
public:
    // 教科书式的迭代
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stk;
        if (root) stk.push(root);

        TreeNode* pre = nullptr;

        while (!stk.empty()) {
            TreeNode* node = stk.top();
            if (node) {
                stk.pop();

                if (node->right) stk.push(node->right);
                stk.push(node); stk.push(nullptr);
                if (node->left) stk.push(node->left);
            } else {
                stk.pop();
                node = stk.top(); 
                stk.pop();

                if (pre != nullptr && pre->val >= node->val) return false;
                pre = node;
            }
        }
        return true;
    }
};
```

递归 :

```C++
class Solution {
public:
 // 教科书式的递归
    TreeNode* pre = nullptr; 
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) return true;

        bool left = isValidBST(root->left);

        if (pre != nullptr && pre->val >= root->val) return false;
        pre = root;

        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

## 遍历

### 深度优先遍历

#### 递归写法

##### 前序(中左右)

```C++
void preOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
    
    preOrder(root->left);
    preOrder(root->right);
}
```

##### ==中序(左中右)==

```C++
void midOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    preOrder(root->left);
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
    
    preOrder(root->right);
}
```

##### 后序(左右中)

```C++
void postOrder(TreeNode* root) {
 if (root == nullptr) {return; }
    
    preOrder(root->left);
    preOrder(root->right);
    
    print(root->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
}
```

#### 迭代写法

下面这种写法能够统一前中后序的代码, 只需改变中间几行的顺序就可以实现三种方式遍历。

核心思想是通过在要处理的节点前面加入一个空指针作为标记，如果循环过程中碰到栈顶是空指针，则立刻弹出空指针，此时栈顶元素即为要处理的节点，即可进行处理。

如果栈顶不是空指针，那就把这个元素先弹出，然后按照前序遍历的顺序翻着压入栈中（因为栈后入先出），即右儿子–左儿子–根节点–空指针的顺序。

##### 前序

```C++
curvoid preOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    while (!stk.empty()) {
  TreeNode* cur = stk.top();
        if (cur) {
            stk.pop();
            
            if (cur->right) stk.push(cur->right); // 右
            if (cur->left) stk.push(cur->left);  // 左
            
            stk.push(cur);       // 中
            stk.push(nullptr);
            
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return;
}
```

##### ==中序==

```C++
void midOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    
    // 这里可能会根据解题需要加入一些东西
    
    while (!stk.empty()) {
        TreeNode* cur = stk.top();
        if (cur) {
            //这一部分不会变
            stk.pop();
            
            if (cur->right) stk.push(cur->right); // 右
            stk.push(cur); stk.push(nullptr);     // 中
            if (cur->left) stk.push(cur->left);  // 左
            
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            //这里自由发挥
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return; // 这里要看不同题目要求返回什么就返回什么
}
```

##### 后序

```C++
void postOrder(TreeNode* root) {
    stack<TreeNode*> stk;
    if (root) stk.push(root);
    while (!stk.empty()) {
  TreeNode* cur = stk.top();
        if (cur) {
            stk.pop();
            
            stk.push(cur);       // 中
            stk.push(nullptr);      
            
            if (cur->right) stk.push(cur->right); // 右
            if (cur->left) stk.push(cur->left); // 左
        } else {
            stk.pop();
            cur = stk.top();
            stk.pop();
            
            print(cur->val); // 这里代表对当前节点进行的操作,可以是打印其值也可以是加入数组等等
        }
    }
    return; // 这里要看不同题目要求返回什么就返回什么
}
```

### 广度优先遍历(层序遍历)

  广度优先搜索需要一个队列，开始先把根节点入队，然后进行如下循环：

把队首节点赋给`current`；

若`current`节点的左儿子存在，入队； 若`current`节点的右儿子存在，入队；

然后首节点出队。

进行上述循环直到队列为空。

**广度优先搜索的代码如下：**

```C++
struct TreeNode {
    int val;
    TreeNode* left, * right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void BFS(TreeNode* root) {
        queue<TreeNode*> Q;
        Q.push(root);
        while (!Q.empty()) {
            TreeNode* current = Q.front();Q.pop();
            if (current->left) Q.push(current->left);
            if (current->right) Q.push(current->right);
            cout << current->val << endl;
        } 
};
```

**==把每一层的节点都处理完再进入下一层的版本== :**

```C++
void BFS(TreeNode* root) {
 queue<TreeNode*> Q;
    Q.push(root);
    while (!Q.empty()) {
  int n = Q.size();
        for (int i = 0; i < n; i++) {
   TreeNode* cur = Q.front(); Q.pop();
            
            //这里写对当前节点的操作...
            
            if (cur->left) Q.push(cur->left);
            if (cur->right) Q.push(cur->right);
        }
    }
    return;
}
```

## 向二叉搜索树中插入节点的算法

```C++
struct TreeNode {
 int val;
    TreeNode* left, * right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution{
public:
    //向根节点为root的二叉搜索树中插入值为val的一个节点
    bool insertBST(TreeNode* root, int val) {
        //递归终止条件：找到一个空位置就创建一个值为val的树节点
        if (!root) root = new TreeNode(val);
        //如果val等于某一个节点值，不符合二叉搜索树的定义，停止插入返回false
        else if (val == root->val) return false;
        //如果val比当前节点值小，就插入到当前节点的左子树中
        else if (val < root->val) insertBST(root->left, val);
        //如果val比当前节点值大，就插入到当前节点的右子树中
        else insertBST(root->right, val);
        return true;
    }
};
```

## 构造二叉树

### 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

不会

### 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

不会

### 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

不会

# 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。

时间复杂度为$O(n)$。
