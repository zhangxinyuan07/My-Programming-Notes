# 操作系统概述

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0.assets/gcc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.drawio.png" alt="gcc工作流程.drawio"  />



## 理解操作系统: 三个根本问题

### 操作系统服务谁?

**程序 = 状态机**

### 操作系统为程序提供什么服务?

**操作系统 = 对象 + API**

### 如何实现操作系统提供的服务?

**操作系统 = C程序**



## 一个合格的操作系统用户

- 会STFW/RTFM自己动手解决问题
- 不惧怕使用任何命令行工具
    - `vim, tmux, grep, gcc, binutils`



## 总结

本次课回答的问题

- **Q1** (Why): 为什么要学操作系统？
- **Q2** (What): 到底什么是操作系统？
- **Q3** (How): 怎么学操作系统？


Take-away message

- 操作系统没有传说中那么复杂
    - 程序视角：对象 + API
    - 硬件视角：一个 C 程序





# 操作系统上的程序

## 到底什么是程序?

### 源代码视角

==**程序就是状态机**==

#### 粗浅理解

C 程序的状态机模型 (语义，semantics)

- 状态 = 堆 + 栈
- 初始状态 = `main` 的第一条语句
- 迁移 = 执行一条简单语句



#### 精准理解

C 程序的状态机模型 (语义，semantics)

- 状态 = stack frame 的列表 (每个 frame 有 PC) + 全局变量
- 初始状态 = main(argc, argv), 全局变量初始化
- 迁移 = 执行 top stack frame PC 的语句; PC++
    - 函数调用 = push frame (frame.PC = 入口)
    - 函数返回 = pop frame



### 二进制代码视角

**==程序还是状态机==**

- 状态 = 内存 M + 寄存器 R
- 初始状态 = (稍后回答)
- 迁移 = 执行一条指令
    - 我们花了一整个《计算机系统基础》解释这件事
    - gdb 同样可以观察状态和执行



#### 操作系统上的程序

- 所有的指令都只能计算
    - deterministic: mov, add, sub, call, ...
    - non-deterministic: rdrand, ...
    - 但这些指令甚至都无法使程序停下来 (NEMU: 加条 `trap` 指令)





- 一条特殊的指令 : **调用操作系统 syscall**
    - 把(M,R)完全交给操作系统，任其修改
        - 一个有趣的问题：如果程序不打算完全信任操作系统？
    - 实现与操作系统中的其他对象交互
        - 读写文件/操作系统状态 (例如把文件内容写入 M)
        - 改变进程 (运行中状态机) 的状态，例如创建进程/销毁自己





- ==**程序 = 计算 + syscall**==
- ==状态机视角的程序: 程序 = 计算 → syscall → 计算 → ...==



#### 本质上, 所有的程序和Hello World 类似

程序 = 状态机 = 计算 → syscall → 计算 →

- 被操作系统加载
    - 通过另一个进程执行 execve 设置为初始状态
- 状态机执行
    - 进程管理：fork, execve, exit, ...
    - 文件/设备管理：open, close, read, write, ...
    - 存储管理：mmap, brk, ...
- 直到 _exit (exit_group) 退出





------------



## 程序的调试

### 如何调试程序?

- 当然是观察程序 (状态机) 的执行了
    - 初学者必须克服的恐惧：STFW/RTFM ([M 非常有用](http://sourceware.org/gdb/documentation/))
    - starti 可以帮助我们从第一条指令开始执行程序
        - ==gdb 可以在两种状态机视角之间切换 (`layout`)==



### 最重要的两个Debug工具

1. `gdb`
2. `strace`



## 总结

本次课回答的问题

- **Q**: 到底什么是 “程序”？



Take-away message

- 程序 = 状态机
    - 源代码 S: 状态迁移 = 执行语句
    - 二进制代码 C: 状态迁移 = 执行指令
    - 编译器 C=compile(S)
- 应用视角的操作系统
    - 就是一条 syscall 指令
- 计算机系统不存在玄学；一切都建立在确定的机制上
    - 理解操作系统的重要工具：gcc, binutils, gdb, strace

